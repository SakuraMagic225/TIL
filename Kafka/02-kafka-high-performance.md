# Kafka高性能的秘诀

> 日期：2026/2/9
> 标签：#Kafka #消息队列 #后端

## Kafka为什么能在磁盘存储下实现极致高性能？
这一个问题是我今天学习前最大的疑问。从上次初步学习Kafka，我确实惊叹它对于主题、分区、副本等这些巧妙的设计。但是发现它是在磁盘存储的，基于之前的一些理解，我一直认为磁盘存储就是会慢（慢的原因其实我也不知道）。

经过今天的学习真的是收获颇多，所以我按照我脑海里一个一个浮现的疑问来整理今天的TIL。

## 磁盘存储的真正痛点
对于磁盘来说，它真正的痛点是**随机读写**，因为它在随机读写的情况下，磁头需要不停地寻道和旋转等待，这样会消耗大量的时间。但是如果是**顺序读写**的话，磁头几乎不需要动，速度会快很多。所以我之前理解的慢其实是相对于随机读写的情况来说的，磁盘在顺序读写下并不慢。


* **Kafka的做法**
根据这一点，Kafka的做法是将分区设计成了一个**Append-only**的日志文件。新的消息永远只追加到文件的末尾，这样就可以利用磁盘在顺序读写下并不慢的特点优化性能。

---

## 页缓存（Page Cache）是什么？
简单来说，**页缓存**就是操作系统为了给磁盘“加速”而在内存（RAM）中开辟的一块临时工作区。

如果使用了页缓存技术，在应用程序想要读写磁盘时，会先找操作系统。在读取数据时，操作系统会进行**预读（Read-Ahead）**；写入数据时，操作系统会异步进行**写回（Write-Back）**，等待磁头不忙的时机进行写入。


* **Kafka的做法**
Kafka并没有在内存中自己维护一个庞大的缓存池，因为Kafka是用Java写的，如果自己在内存中存大量数据，JVM的垃圾回收机制会变得很慢。为了**避免JVM的内存开销**，Kafka就选择把缓存任务直接交给了操作系统，也就是页缓存技术。

---

## 为什么Kafka要把数据从硬盘发给网卡？
在计算机里，网卡负责把电脑内部的数字信号转换成网络电缆（或 Wi-Fi 波）能传输的信号。

而Kafka的核心本质时一个消息的**中转站**，它要负责将生产者的消息保存到硬盘中防止丢失，还要负责在消费者需要的时候将消息发给消费者，因此需要将数据从硬盘发给网卡，之后从网卡传输给消费者。

---

## 零拷贝技术
数据从硬盘到网卡，这个过程非常的曲折，先来看传统的传输过程（“四次切换、四次拷贝”）：
1. **用户态->内核态**：Kafka调用read()，CPU切换到内核态（用户态无法直接操作硬件）。
2. **拷贝1（硬盘->页缓存）**：通过DMA将数据从硬盘读取到页缓存。
3. **拷贝2（页缓存->用户缓冲区）**：CPU将数据从内核空间拷贝到 Kafka 的内存空间（用户态）。（这次切换和拷贝非常耗时）
4. **内核态->用户态**： read() 返回，CPU 切换回用户态。
5. **用户态->内核态**：Kafka调用send()，CPU再次切换到内核态。
6. **拷贝3（用户缓冲区->Socket缓冲区）**：CPU再次把数据从Kafka内存拷贝到内核的Socket缓冲区。
7. **拷贝4（Socket缓冲区->网卡）**：通过DMA将数据发往网卡。
8. **内核态->用户态**：send()返回，切换回用户态。

这整个过程不仅切换状态麻烦，还让CPU搬运了两次数据，效率太低。

对此Kafka利用了Linux的sendfile系统调用，告诉系统“我不用看数据，你直接发走就行”：
1. **用户态->内核态**：Kafka调用read()，CPU切换到内核态。
2. **拷贝1（硬盘->页缓存）**：数据从硬盘读取到页缓存。
3. **拷贝2（页缓存->网卡）**：此时，数据根本不需要经过 Kafka 的内存。内核直接把页缓存里的数据描述符发给 Socket 缓冲区，由 DMA 硬件直接把数据从页缓存传给网卡。
4. **内核态->用户态**：send()返回，切换回用户态。

整个过程将原本4次上下文切换优化成了2次，数据拷贝从4次也变成了2次，CPU占用近乎为0，大大提高了效率。

> 零拷贝技术中的“零拷贝”指的其实是“零CPU拷贝”。

---

## 总结
Kafka 的核心设计哲学是**减少摩擦**。它通过充分利用硬件特性和操作系统底层机制，将磁盘 IO 跑出了接近内存的性能。以下是其高性能的三大支柱：
#### 1.顺序读写（Sequential I/O）—— 避开磁盘痛点
#### 2.页缓存（Page Cache）—— 借力操作系统
#### 3.零拷贝技术（Zero-Copy）—— 内核态的“传送阵”

另外还有kafka的**批量处理与数据压缩**以及**分区并发**，也是让它拥有高性能的有效手段，但是在这里就不展开说了。

---

## 个人学习心得
今天的学习是对Kafka的更加深入的理解，虽说是深入，但其实对于其中的核心技术完全没有去剖析，比如sendfile技术等，但是对于我现在这个阶段来说以及完全够我消化一阵了。这些内容让我受益匪浅，同时我也认识到自己计算机组成原理和操作系统的薄弱，这些知识真的很重要，之后要多上心才是。之后要开始进入实践了，在Java中尝试使用一下Kafka。